<div class="container pt-2">
    <h1>SIMD (A.K.A Instrinsic Instructions)</h1>
    <hr>
    <h2>Introduction</h2>
    <p>
        This is a partical introduction to SIMD in C++. Other languages such as C# also allow this kind of operations
        but require their own
        API to do so. I will assume that you are comfortable to read simple C++ code and have a basic understanding of
        pointers.
    </p>
    <h2>Data types recap</h2>
    <p>
        I'm sure that somewhere somehow you have heard that different data tyes have different sizes. For example
        <code>char</code> is 1 byte (8 bits),
        <code>float</code> and <code>ints</code> are 4 bytes (32 bits) and <code>longs</code> and <code>doubles</code>
        are 8 bytes (64 bits) adn yes
        it also depends on machine and operating system but nowadays it is the most common. So why does this matter?
        Well because with instrinsic operations
        you have a new primitive types which are 16 bytes wide (126 bits) and 32 bytes wide (256 bits). CPUs actually
        has a special register for them:
    <ul>
        <li>XMM0-XMM15 which are 16 bytes wide (SSE data types)</li>
        <li>YMM0-YMM15 which are 32 bytes wide (AVX data types)</li>
    </ul>
    <h4>SSE data types</h4>
    <table class="table table-bordered">
        <tbody>
            <tr>
                <td>__m128</td>
                <td>float</td>
                <td>float</td>
                <td>float</td>
                <td>float</td>
                <td>4 x 32 bit float</td>
            </tr>
            <tr>
                <td>__m128i</td>
                <td>int</td>
                <td>int</td>
                <td>int</td>
                <td>int</td>
                <td>4 x 32 bit integer</td>
            </tr>
            <tr>
                <td>__m128d</td>
                <td colspan="2">double</td>
                <td colspan="2">double</td>
                <td>2 x 64 bit double</td>
            </tr>
        </tbody>
    </table>
    <h4>AVX data types</h4>
    <table class="table table-bordered">
        <tbody>
            <tr>
                <td>__m256</td>
                <td>float</td>
                <td>float</td>
                <td>float</td>
                <td>float</td>
                <td>float</td>
                <td>float</td>
                <td>float</td>
                <td>float</td>
                <td>8 x 32 bit float</td>
            </tr>
            <tr>
                <td>__m256i</td>
                <td>int</td>
                <td>int</td>
                <td>int</td>
                <td>int</td>
                <td>int</td>
                <td>int</td>
                <td>int</td>
                <td>int</td>
                <td>8 x 32 bit integer</td>
            </tr>
            <tr>
                <td>__m256d</td>
                <td colspan="2">double</td>
                <td colspan="2">double</td>
                <td colspan="2">double</td>
                <td colspan="2">double</td>
                <td>4 x 64 bit double</td>
            </tr>
        </tbody>
    </table>
    </p>
    <h2>How do we use it?</h2>
    <p>
        Lets start with a simple program:
    </p>
    <CodeViewer @code={{this.snippet1}} />
    <p>
        First things first we need to include the appropriate headers. We include <code>nmmintrin</code> when we are
        working with SSE and include <code>immintrin</code>
        when we are working with AVX.
    </p>
    <p>
        Inside <code>main</code> function we define two <code>__m128</code> operands and set their four
        <code>floats</code> with <code>_mm_set_ps</code>. Although we are working
        with SSE the <code>_mm_set_ps</code> is an sequential instruction, i.e. each of <code>__m128</code> values will
        be set one after another in sequence. How do
        I know it? Well Intel has a great <a id="intel-documentation" data-trigger="focus" role="button" href="#!"
            data-toggle="popover">documentation</a> about it, you should definitely check out.
    </p>
    <p>
        Then we add all values of <code>a</code> with all values of <code>b</code> in a single <a id="instruction-info"
            data-trigger="focus" role="button" href="#!" data-toggle="popover">instruction</a> and store the result in
        <code>res</code>.
    </p>
    <h2>Get the results back</h2>
    <p>
        There are multiple ways to get the values from SSE variables. One way is to use SSE operations themselves as
        such:
    </p>
    <CodeViewer @code={{this.snippet2}} />
    <pre>Output:<code>4, 3, 2, 1</code></pre>
    <p>
        The <code>_mm_store_ps</code> will retrieve our values from an SSE variable but as you can see index 0 refers to
        last position in <code>_mm_set_ps</code>. Another
        way to get our values is by using casts as follow:</p>
    <CodeViewer @code={{this.snippet3}} />
    <pre>Output:<code>4, 3, 2, 1</code></pre>
    <p>
        Note that it will return the same output as the previous one. One last method that I want to show is by using
        <a href="https://en.cppreference.com/w/cpp/language/union">unions</a>:
    </p>
    <CodeViewer @code={{this.snippet4}} />
    <p>
        The last two techniques can also be used to set an SSE variable. With this knowledge in mind we can start with
        optimizations using SIMD instructions.
    </p>
    <h2>The Setup</h2>
    <p>
        Lets suppose we are building a game and we are now writing the section responsable for dealing damage to all
        entities caused by an explosion. Lets define
        our rules for the explosion.
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/explosion_rules.png" width="350px">
    </div>
    <p>
        Our explosion will have two radius (R<sub>1</sub> and R<sub>2</sub>). The inner radius will deal the total
        amount of damage caused by explosion. The outter radius
        will have calculated damage, i.e. farther an entity is from the center of the explosion less damage it will
        take. Note that both R<sub>1</sub> and R<sub>2</sub>
        have their origin at the center of the explosion.
    </p>
    <p>
        After our first coding iterations we could end up with something like this.
    </p>
    <CodeViewer @code={{this.snippet5}} />
    <h2>Branchless Execution</h2>
    <p>
        The first step to improve performance is to remove all conditions we have inside our <code>for loop</code>. To
        do that we could
        apply the partial damage (<code>1 - (distance - explosion->r1 / (explosion->r2 - explosion->r1))</code>) to all
        entities but this has two
        problems:
    <ol>
        <li>
            It would calculate this factor for all entities even if they are outside the explosion radius. This is bad
            because if all entities are outside
            this still would be calculated for every single entity compared to no calculations at all. It would also add
            extra operations for those who are inside
            inner radius even though they would only require one subtraction.
        </li>
        <li>
            If you do the maths you will find out that for those entities that are inside inner radius would take more
            damage that is defined in <code>Explosion</code>
            struct which could be a nice feature but it is not what we want here. Also for those entities that are
            outside explosion radius would actually have
            an healing effect which could be a feature for another game.
        </li>
    </ol>
    </p>
    <p>
        For the first problem we have no solution. It is what it is. But we could still would have performance increase
        even though we are doing more computation
        than what is needed. This is because we removed the possibility of <a
            href="https://en.wikipedia.org/wiki/Branch_predictor">branch perdiction</a> and our calculations are
        relatively simple which are very
        fast anyway.
    </p>
    <p>
        For the second problem what we really need is to clamp our factor between 0 and 1. This would prevent the
        explosion from dealing more damange than defined or
        from healing entities. To achieve this we apply <code>std::min</code> and <code>std::max</code> to our damage
        factor. Our function now looks like this:
    </p>
    <CodeViewer @code={{this.snippet6}} />
    <div class="alert alert-primary" role="alert">
        <b>Note!</b>
        <p>
            Even though we are using <code>std::min</code> and <code>std::max</code> they internally use
            <a href="https://www.w3schools.com/cpp/cpp_conditions_shorthand.asp">ternary operator</a> which are
            conditionals. But there are CPU level instructions which can calculate min and max in one go as we will se
            in the following section.
        </p>
    </div>
    <h2>Time for improvement with SIMD instructions</h2>
</div>