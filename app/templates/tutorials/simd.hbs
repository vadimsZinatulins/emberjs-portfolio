<div class="container">
    <h1>SIMD Instructions</h1>
    <hr>
    <h2>Motivation</h2>
    <p style="text-align: justify;">
        Suppose you are writing a game and at some point you have reached a phase where you want to optimize what you
        already have before moving on. Skimming through you code base and you have found the following code which
        applies gravity to all your entities in the scene. To simplify things we won't use inheritance which means
        we would have a monolitic class <code>Entity</code> in our game. For the purpose of this tutorial this is
        fine since <code>Entity</code> class in very small anyway.
    </p>
    <div class="alert alert-primary" role="alert">
        <strong>Note!</strong>
        <p style="text-align: justify;">
            Using this <code>Entity</code> as we are using in example below is very rarely found in games. What is most
            common to be found is a base class <code>GameObject</code> and having multiple classes (<code>Player</code>,
            <code>Monster</code>, etc) to derive from it. This have advantages but have negative impacts in
            performance. Here I'm being very generous and giving an headstart to our <code>Entity</code> class which
            will be further improved in terms of performance.
        </p>
    </div>
    <CodeViewer @code={{this.cpp_snippet_1}} />
    <p style="text-align: justify;">
        So you have decided that you want to measure how much time does it takes to aply gravity to every entity each
        frame. Furthermore you want to measure it with different entities count to have a rough estimate how does
        performance change with the entities growth.
    </p>
    <p style="text-align: justify;">
        So you created a profiler, done some measurements multiple times and averaged the results. Pulled out your
        favourite chart creation tool and came up with these results:
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/measurement_01.png" width="100%">
    </div>
    <br>
    <div class="alert alert-primary" role="alert">
        <strong>Note!</strong>
        <p style="text-align: justify;">
            If you try to run this test on your machine you're likely to get different values. This is because there are
            many factors that impacts the performance (such as operating system, tasks running in background, CPU, etc).
        </p>
    </div>
    <p style="text-align: justify;">
        Note that execution times comes in <a id="microsecond-reminder" data-trigger="focus" role="button" href="#"
            onclick="return false;" data-toggle="popover" {{did-insert this.popovermicrosecondHelper}}>microseconds</a>.
        Now lets suppose you have other systems in your game that require more time so you must open reduce execution
        time other parts.
    </p>
    <p>
        Remember that if you want to achieve 30 stable FPS you frame must update under (approximately) 33ms.
        In our case it would take 4.4ms to update 131 072 entities which is about 13.3% out of 33ms. Lets suppose we
        have
        measured the execution time of all of our systems and calculated the time it requires of a single 33ms frame.
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/time_partition.png" width="50%">
    </div>
    <br>
    <p style="text-align: justify;">
        If we wanted to add more systems we only had 14.2% of 33ms (which is about 4.7ms). So you want to open more
        space there and decided to start from Gravity System because it is the easiest of them all and you know how to
        do it quickly. In real scenario you'll probably start from the most expensive system but for the sake of this
        tutorial we'll start with Gravity System.
    </p>
    <h2>SIMD Instructions</h2>
    <p style="text-align: justify;">
        SIMD instructions is what allow to do parallel calculations without use of threads. It stands for <b>S</b>ingle
        <b>I</b>nstruction <b>M</b>ultiple <b>D</b>ata also know as intrinsic functions or vectorized instructions. With
        one single instruction you can work on multiple data. Pretty cool, right? But before start using them we need to
        recap our basic knowledge about data types.
    </p>
    <p style="text-align: justify;">
        I'm pretty sure that somewhere somehow you have heard that different data tyes have different sizes. For
        example <code>char</code> is 1 byte (8 bits), <code>float</code> and <code>int</code> is 4 bytes
        (32 bits) and <code>long</code> and <code>double</code> is 8 bytes (64 bits) and yes it depends on CPU and
        operating system you have but nowadays it is the most common to find. So why does this matter? Well because with
        SIMD instructions you have a new primitive types which are 16 bytes wide (126 bits). With this size you can fit
        4 <code>floats</code> or 4 <code>ints</code> inside and manipulate them all at the same time (or instruction as
        I should say). There are actually even bigger data types available namely 32 bytes (256 bits) and even 64 bytes
        (512 bits) but you should check if you CPU <a id="cpu-simd-support" data-trigger="focus" role="button" href="#"
            onclick="return false;" data-toggle="popover" {{did-insert this.popoverCpuSupport}}>supports</a>
        these kind of data types before using them. CPUs actually has a special <a
            href="https://en.wikipedia.org/wiki/Processor_register">register</a> for them:
    </p>
    <ul>
        <li>XMM0-XMM15 which are 16 bytes wide (SSE data types)</li>
        <li>YMM0-YMM15 which are 32 bytes wide (AVX data types)</li>
        <li>ZMM0-YMM15 which are 64 bytes wide (AVX-512 data types)</li>
    </ul>
    <div class="alert alert-primary" role="alert">
        <strong>Note!</strong>
        <p style="text-align: justify;">
            Somes times you'll find people refering to SSE, AVX and AVX-512 as AVX, AVX2 and AVX-512 but I will stick
            with the former naming as it is what you can find on <a
                href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">Intel's Documentation</a>.
        </p>
    </div>
    <p style="text-align: justify;">
        Bellow you can see what are the SIMD data types (for <span class="badge badge-pill"
            style="background-color: darkgray;">SSE</span>, <span class="badge badge-pill"
            style="background-color: lightgreen;">AVX</span> and <span class="badge badge-pill"
            style="background-color: yellow;">AVX-512</span>), their sizes and what can they hold (<code>float</code>,
        <code>int</code> or <code>double</code>).
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/data_types_sizes.png" width="100%">
    </div>
    <br>
    <p style="text-align: justify;">
        Now image what it is to manipulate 4, 8 or even 16 values at the same time. It is a huge performance increase. I
        hope that by this point you're already interested in explore more about SIMD.
    </p>
    <h2>How can we use it?</h2>
    <p style="text-align: justify;">
        First we need to include appropriate header files to take advantage of SIMD:
    </p>
    <CodeViewer @code={{this.cpp_snippet_2}} />
    <p style="text-align: justify;">
        Then lets create a simple program that adds 4 float with another 4 floats.
    </p>
    <CodeViewer @code={{this.cpp_snippet_3}} />
    <p style="text-align: justify;">
        To initialize a <code>__m128</code> variable we use <code>_mm_set_ps</code> which takes 4 floats and returns a
        <code>__m128</code>.
    </p>
    <div class="alert alert-danger" role="alert">
        <strong>Warning!</strong>
        <p style="text-align: justify;">
            Do not be fooled here. Although we are working with intrinsic operations the <code>_mm_set_ps</code> is
            actually setting <code>__m128</code> values sequentially. By this I mean it sets 32 bits of
            <code>__m128</code> one at the time (i.e. one instruction per each value set). How do I know it? Well Intel
            has a great <a id="intel-documentation" onclick="return false;" data-trigger="focus" role="button" href="#"
                data-toggle="popover" {{did-insert this.popoverIntelDocumentation}}>documentation</a> about it,
            you should definitely check out.
        </p>
    </div>
    <p style="text-align: justify;">
        We then use <code>_mm_add_ps</code> to add our floats together all in one instruction. I should mention that
        having things done in one instruction doesn't meen that it will be done in one CPU Clock Cycle. It would
        actually take about 3-4 cycles to complete the instruction. But don't worry most of CPU instructions take more
        than 1 cycle to complete and SIMD instructions are not different.
    </p>
    <p style="text-align: justify;">
        In the previous sample we are only using addition, we can can also perform subtraction, multiplication, division
        and mny other crazy operations. Nearly everything you can do with scalars you can do with SIMD instruction.
    </p>
    <p style="text-align: justify;">
        If you need you can also create <code>__m128</code> from a single <code>float</code> by calling
        <code>_mm_set_ps1</code> which takes one <code>float</code> as an argument and returns <code>__m128</code> with
        all 32 bits set to the <code>float</code> value. If you want you can even load data from a pointer.
    </p>
    <CodeViewer @code={{this.cpp_snippet_4}} />
    <p style="text-align: justify;">
        Note that our variable <code>values</code> in the previous example is of type <code>float const *</code>. This
        is no accident, the <code>_mm_load_ps</code> actually require <code>float const *</code> as an argument. Because
        of this people tend cast the <code>float *</code> directly to <code>__m128 *</code> and then dereference it when
        using functions.
    </p>
    <CodeViewer @code={{this.cpp_snippet_5}} />
    <p style="text-align: justify;">
        Another common way to set <code>__m128</code> variables is by using <a
            href="https://en.cppreference.com/w/cpp/language/union">unions</a> which allows you type to behave like one
        type or another type suiting your needs at that moment. This is perfect for this scenario because sometimes need
        might need <code>__m128</code> and other times we might need <code>float[4]</code>:
    </p>
    <CodeViewer @code={{this.cpp_snippet_6}} />
    <p style="text-align: justify;">
        Using unions has an advantage because we can set values very quickly and also retrieve them. Speaking of which,
        how do we get our results back? One way would be by using unions:
    </p>
    <CodeViewer @code={{this.cpp_snippet_7}} />
    <pre>Output:<code>9, 8, 7, 6</code></pre>
    <p style="text-align: justify;">
        Another way would be to cast values to <code>float *</code> and then access them individually. But you've
        probably guessed that there is a function for that aswell namely <code>_mm_store_ps</code>.
    </p>
    <CodeViewer @code={{this.cpp_snippet_8}} />
    <pre>Output:<code>8, 7, 6, 5</code></pre>
    <p style="text-align: justify;">
        Note how the output came in reversed order. This is because the <code>_mm_set_ps</code> sets values in reversed.
        If you want to maintain the order you would probably want to call <code>_mm_setr_ps</code>.
    </p>
    <p style="text-align: justify;">
        There is much more you can do with SIMD. You can do bitwise operations, comparisons, trigonometry, probabilistic
        operations and more. If you want something specific just check the <a
            href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/">Intel's Documentation</a>.
    </p>
    <p style="text-align: justify;">
        Oh one more thing I forgot to mention. We'll only be working with SSE here but if you want to use AVX or even
        AVX-512 you just use appropriate naming for the functions (for example instead of <code>_mm_set_ps</code> you
        can use <code>_mm256_set_ps</code> or <code>_mm512_set_ps</code>) and variable types.
    </p>
    <h2>Back to Business</h2>
    <p style="text-align: justify;">
        Lets get back to our initial game where we apply gravity to each entity and see what can we do to improve it's
        performance.
    </p>
    <p style="text-align: justify;">
        First thing that needs to be done is to remove the gravity update from the
        <code>Entity::update(float deltaTime)</code> since it will be done to multiple entities at the same time. We'll
        create a new <code>update</code> function that will only do gravity related work. Then we must convert our
        entities' attributes to <code>__m128</code> so we can apply SIMD operations followed by SIMD operations
        themselves. Finaly we must update entities' attributes with newly calculated values.
    </p>
    <CodeViewer @code={{this.cpp_snippet_9}} />
    <p style="text-align: justify;">
        The final result is much much bigger code but it pays off after you measure the performance of this new
        <code>update</code> function. But before that take a look at the final part of the code. It is storing values
        back to entities in reversed order. This is because of <code>_mm_set_ps</code> set ordering as explained
        previously.
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/measurement_02.png" width="100%">
    </div>
    <br>
    <p style="text-align: justify;">
        If you do rough calculations you'll see that our new <code>update</code> function is about 4 times faster. This
        means that those 13.3% of time execution is now (approximately) 3.3ms which translates to 24.2% of remaining
        time (or 8ms) to implement new systems which is better than our previous 14.2% (or 4.7ms).
    </p>
    <p style="text-align: justify;">
        Okay this is a very simple problem so lets try to tackle a little bit more complicated one and see if we can
        still get performance increase.
    </p>
    <h2>Fun with explosions</h2>
    <p style="text-align: justify;">
        I know that this is getting a very long tutorial but I want to go through one more example before wrapping up.
        Lets suppose you want to implement an explosion system. You want your explosion to deal total damage (defined in
        <code>Explosion</code> class) to all entities that lie inside the radius R<sub>1</sub> and a calculated damage
        based on distance from the center of explosion for those entities that lie inside the radius R<sub>2</sub> buy
        outside R<sub>1</sub>.
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/explosion_rules.png" width="45%">
    </div>
    <br>
    <p style="text-align: justify;">
        You went through first coding iteration and came up with something like this:
    </p>
    <CodeViewer @code={{this.cpp_snippet_10}} />
    <p style="text-align: justify;">
        And then, as a cool programmer as you are, you decided to measure its performance.
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/measurement_03.png" width="100%">
    </div>
    <br>
    <p style="text-align: justify;">
        With 131 072 entities your explosion updates roughly in 0.6ms which is way under the remaining time you had
        (8ms) for new systems. And even if you had multiple explosions at the same time it would still update all of
        them in ok (ish) time. But can you do better? Of course you can! By using SIMD instructions you will definitely
        improve the performance. The only thing you need to do is to figure out how to remove this conditionals inside
        <code>for loop</code>.
    </p>
    <h2>Branchless Update</h2>
    <p style="text-align: justify;">
        So you sat and your desk, scratched your head for while and figured out that the one way to remove those
        conditionals was by applying that explosion calculation
        (<code>1 - ((distance - explosion->r1) / (explosion->r2 - explosion->r1))</code>) to all entities no matter
        what. But this would have two consequences:
    </p>
    <ul>
        <li style="text-align: justify;">
            If you quick maths you'll find out that by doing this way all entities that are inside radius R<sub>1</sub>
            would actually take more damage that is define in the <code>Explosion</code> class which could be ok but for
            the sake of this tutorial it is not what we want. Also for those entities that are outside explosion radius
            they would suffer an healing effect which is weird for an explosion to do so it is out of the question
            feature.
        </li>
        <li style="text-align: justify;">
            IT would still calculate damage for all entities that lie outside of the explosion radius which means more
            CPU instructions compared to no instructions at all which is definitely a decrease of performance. Also if
            all entities lie inside the radius R<sub>1</sub> it would perform again those calculations instead of one
            subtraction which again is no good. For this case the ideal solution would be if all entities were between
            R<sub>1</sub> and R<sub>2</sub>.
        </li>
    </ul>
    <p style="text-align: justify;">
        By knowing these two facts it is still a bad ideia? Not really. We can workout the first fact. The explosion
        would deal more damage because the result of the calculation would output an value that is greater that
        <code>1.0f</code> so the only thing we would need to prevent this is to clamp it to <code>1.0f</code>. This can
        be easily achieved by using <code>max</code> function (like
        <code>damageFactor = std::max(1.0f, damageFactor);</code>). And it would have an healing effect if the
        calculated value is negative (i.e. bellow <code>0.0f</code>) which can also be amended with <code>min</code>
        function (like <code>damageFactor = std::min(0.0f, damageFactor);</code>). Wait a minute, doesn't
        <code>min</code> and <code>max</code> use <code>if</code> statements? Technically yes, but since I know there
        are SIMD instructions for <code>min</code> and <code>max</code> operations we are going to use them (<a
            id="oh-no-popover" data-trigger="focus" role="button" href="#" onclick="return false;" data-toggle="popover"
            {{did-insert this.popoverHoNo}}>didn't want to spoil it here</a> but now you know whats coming).
    </p>
    <p style="text-align: justify;">
        Now for the second fact it is what it is. There is nothing we can do about it (well actually there is but for
        that we would need to talk about <a id="dod-popover" data-trigger="focus" role="button" href="#"
            onclick="return false;" data-toggle="popover" {{did-insert this.popoverDod}}>Data Oriented Design</a>). The
        following is the code for this new update function:
    </p>
    <CodeViewer @code={{this.cpp_snippet_11}} />
    <p style="text-align: justify;">
        But what does this translates to performance measurement? I'm glad you asked here are the results I've obtained:
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/measurement_04.png" width="100%">
    </div>
    <br>
    <p style="text-align: justify;">
        As it is possible to see, branchless update execution time is actually worst than original update only when we
        have "few" entities. But as these grow up in number the branchless execution becomes faster than original
        update. At this point I cannot exactly explain why this is happening but my best guess would be bad
        <a href="https://en.wikipedia.org/wiki/Branch_predictor">branch perdiction</a> from CPU (which actually would be
        called branch misprediction).
    </p>
    <p style="text-align: justify;">
        So now we have everything setup for applying SIMD operations.
    </p>
    <h2>Explosion Update with SIMD</h2>
    <p style="text-align: justify;">
        At this point we are are transforming our previous update to SIMD version by starting with declarations of some
        <code>__m128</code> values. These variables take their values from <code>Explosion</code> attributes. Then we
        loop through all entities four at the time and calculate our damage factor. Note the use of
        <code>_mm_min_ps</code> and <code>_mm_max_ps</code>. These are done in one instruction. They don't have any
        <code>if else</code> inside which is preety neat. Lastly we calculate the new health value for our entities and
        set them.
    </p>
    <CodeViewer @code={{this.cpp_snippet_12}} />
    <p style="text-align: justify;">
        The moment of truth. How much faster is this new version compared to our previous iterations?
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/measurement_05.png" width="100%">
    </div>
    <br>
    <p style="text-align: justify;">
        It seems that our new <code>update</code> function is about 3.5x faster than our initial <code>update</code>.
        Why not 4x faster? Well we might gain a lot from operating on 4 entities at the same time but we also loose some
        performance with all those convertions from and to <code>__m128</code>. But this is still a win.
    </p>
    <h2>Squeezing extra performance</h2>
    <p style="text-align: justify;">
        I said that we loose some performance by doing those data types convertions back and forth. Can we get rid of
        those? Not really but we can mitigate their impact. Whenever we call <code>_mm_set_ps</code> it must go through
        every entity and grab the respective attribute which is done sequentially. It can be even worst if entities are
        in different cache lines because it would mean that CPU must wait for the cache line to arrive to it can grab
        the value it needs (as opposed to if they would be in the same cache line there would be no wait time).
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/data_retrieval.png" width="100%">
    </div>
    <br>
    <p style="text-align: justify;">
        What would be really convenient is to be able to use <code>_mm_load_ps</code> which sets <code>__m128</code>
        values in one instruction. But this requires that our data is in contiguous array because
        <code>_mm_load_ps</code> takes an pointer as an argument and uses the first 4 values it finds. This can be done
        by using what is called Structure of Arrays (SoA) which requires use to rethink how we use our entities and
        therfore restructure it. Instead of having <code>array</code> of <code>Entity</code> classes we now have an
        class which which will contains array of attributes of each entity like so:
    </p>
    <CodeViewer @code={{this.cpp_snippet_13}} />
    <p style="text-align: justify;">
        This might look counterintuitive but doing things this way has mny benefits one of which is performance. I wont
        go into details about why it is so but the gist is chache efficiency. For our purpose having a data structure
        like this what does it mean? Well, it means that we are now able to make use of <code>_mm_load_ps</code> because
        all of our values are in a contiguous array.
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/efficient_data_retrieval.png" width="100%">
    </div>
    <br>
    <p style="text-align: justify;">
        We can also take advantage of <code>_mm_store_ps</code> because of
        the same reasons. The <code>_mm_store_ps</code> stores an <code>__m128</code> into a <code>float *</code> using
        first 4 float addresses of the pointer. This allows us to set and load <code>__m128</code> values much faster.
        Lets take a look of the final version of <code>update</code> function:
    </p>
    <CodeViewer @code={{this.cpp_snippet_14}} />
    <p style="text-align: justify;">
        Note that in the previous code I'm actually using a cast isnted of <code>_mm_load_ps</code> thats because it
        actually takes an <code>float const *</code> as an argument so to avoid headaches I've ust used cast. Also our
        <code>for loop</code> is a lote smaller compared to previous one. And after performance measurement these are
        the results:
    </p>
    <div class="text-center">
        <img src="/images/tutorials/simd/measurement_06.png" width="100%">
    </div>
    <br>
    <p style="text-align: justify;">
        It is nearly 2 times faster than our previous one. And with that we conclude this tutorial.
    </p>
    <h2>Conclusion</h2>
    <p style="text-align: justify;">
        I knwo that this is a long tutorial but I wanted to cover not only the basics of SIMD Instructions but also got
        through one example where we convert a simple code to a SIMD version and another example where we convert the
        code to an branchless version first and then to a SIMD version. Not all code can be converted to SIMD some must
        be done in parts (i.e. converting to SIMD back and forth multiple times) specially when you have more complex
        conditionals that the complete operations cannot be represented mathematically.
    </p>
    <p style="text-align: justify;">
        I deliberately omitted the performance measurement code because I don't want the you to focus too munch about
        it. But if you feel you need to know how it was done you can always check the <a
            href="https://github.com/vadimsZinatulins/SIMD-Instructions">Github</a> project, the code you'll find there
        still contains them.
    </p>
    <p style="text-align: justify;">
        I hope you've learned something from here. Also if you have found any typo or something needs more
        clarifications feel free to reach me via <a href="mailto: vadimz2@hotmail.com">email</a> as it I use most.
    </p>
</div>